"""The main window of the application, orchestrating all UI and hardware components.

This module defines the `MainWindow` class, which serves as the primary container
for the entire graphical user interface. Its responsibilities include:
-   Constructing the main UI layout, including camera panels, control tabs,
    menus, and the status bar.
-   Managing the lifecycle of hardware objects, such as the CT400 device and
    Vimba cameras.
-   Orchestrating the "lazy initialization" of hardware on background threads
    to keep the UI responsive on startup.
-   Connecting signals from hardware and worker objects to slots in the UI
    widgets to update the display.
-   Providing top-level application actions, such as connecting/disconnecting
    instruments and showing dialogs.
-   Coordinating a graceful shutdown of all hardware and threads when the
    application closes.
"""

import logging
import sys
from enum import Enum, auto

import numpy as np
from PySide6 import QtGui, QtWidgets
from PySide6.QtCore import (
    QObject,
    QRunnable,
    QSize,
    Qt,
    QThread,
    QThreadPool,
    QTimer,
    Signal,
    Slot,
)
from PySide6.QtGui import QAction, QFont, QIcon
from PySide6.QtWidgets import (
    QApplication,
    QFrame,
    QHBoxLayout,
    QLabel,
    QMainWindow,
    QMenu,
    QMessageBox,
    QSizePolicy,
    QSplitter,
    QStatusBar,
    QTabWidget,
    QVBoxLayout,
    QWidget,
)
from vmbpy import VmbCameraError, VmbSystem, VmbSystemError

from config_model import AppConfig, CameraConfig
from hardware.ct400_init_worker import CT400InitWorker
from hardware.dummy_ct400 import DummyCT400
from hardware.piezo import PiezoController, PiezoError
from hardware.piezo_init_worker import PiezoInitWorker
from ui.alignment_panel import AlignmentPanel
from ui.discovery_dialog import CameraDiscoveryDialog
from ui.theme import CT400_CONTROL_PANEL_STYLE

try:
    # This file is generated by pyside6-rcc and contains compiled resources
    import resources.resources_rc as resources_rc  # noqa: F401
except ImportError:
    # This warning is helpful for developers running the app without compiling resources
    print(
        "Warning: Compiled resource file (resources_rc.py) not found. Icons might be missing.",
        file=sys.stderr,
    )

from hardware.camera import VimbaCam
from hardware.camera_init_worker import CameraInitWorker
from hardware.ct400 import CT400
from hardware.interfaces import AbstractCT400
from ui.camera_widgets import CameraPanel
from ui.constants import (
    ID_CT400_STATUS_LABEL,
    MSG_CAMERA_CONNECTING,
    MSG_CAMERA_FAILED,
    MSG_CAMERA_WAITING,
    PROP_STATUS,
)
from ui.control_panel import (
    CT400ConnectionWorker,
    CT400ControlPanel,
    HistogramControlPanel,
    ScanSettings,
)
from ui.plot_widgets import HistogramWidget, PlotWidget

logger = logging.getLogger("LabApp.main_window")


class PiezoConnectionSignals(QObject):
    """Signals for the PiezoConnectionWorker."""

    connection_succeeded = Signal(str)  # side: "left" or "right"
    disconnection_succeeded = Signal(str)  # side
    connection_failed = Signal(str, str)  # side, error_message


class PiezoConnectionWorker(QRunnable):
    """A QRunnable to handle connecting/disconnecting a Piezo in the thread pool."""

    def __init__(self, piezo: PiezoController, side: str, port: str, connect: bool):
        super().__init__()
        self.piezo = piezo
        self.side = side
        self.port = port
        self.do_connect = connect
        self.signals = PiezoConnectionSignals()

    @Slot()
    def run(self):
        try:
            if self.do_connect:
                self.piezo.connect(self.port)
                self.signals.connection_succeeded.emit(self.side)
            else:
                self.piezo.disconnect()
                self.signals.disconnection_succeeded.emit(self.side)
        except Exception as e:
            logger.error(f"Piezo {self.side} operation failed: {e}", exc_info=True)
            self.signals.connection_failed.emit(self.side, str(e))


class CT400Status(Enum):
    """Defines the possible connection states for the CT400 device."""

    CONNECTED = auto()
    DISCONNECTED = auto()
    CONNECTING = auto()
    DISCONNECTING = auto()
    ERROR = auto()
    UNAVAILABLE = auto()
    UNKNOWN = auto()


class MainWindow(QMainWindow):
    """The main application window.

    This class builds the user interface, manages hardware initialization and
    cleanup, and connects all the components of the application.

    Attributes:
        config (AppConfig): The validated application configuration object.
        cameras (list[VimbaCam]): A list of successfully initialized camera objects.
        camera_panels (dict[str, CameraPanel]): A dictionary mapping camera
            identifiers to their corresponding UI panel widgets.
        ct400_device (AbstractCT400 | None): The active CT400 device instance,
            which could be a real or dummy implementation.
    """

    def __init__(self, config: AppConfig, parent=None):
        """Initializes the MainWindow.

        Sets up the main UI components and defers the slow hardware
        initialization to a later stage to ensure the window appears quickly.

        Args:
            config: The validated AppConfig object containing all startup settings.
            parent: The parent widget, typically None for the main window.
        """
        super().__init__(parent)
        self.config = config
        logger.info("Initializing MainWindow...")
        # --- Member variable initialization ---
        self.cameras: list[VimbaCam] = []
        self.camera_panels: dict[str, CameraPanel] = {}

        # --- CT400 and Piezo hardware will be None until workers finish ---
        self.ct400_device: AbstractCT400 | None = None
        self.piezo_left: PiezoController | None = None
        self.piezo_right: PiezoController | None = None

        # --- CT400 Worker ---
        self.ct400_init_thread: QThread | None = None
        self.ct400_init_worker: CT400InitWorker | None = None

        # --- Piezo Worker ---
        self.piezo_init_thread: QThread | None = None
        self.piezo_init_worker: PiezoInitWorker | None = None

        self.shared_scan_settings = ScanSettings()
        self.vmb_instance: VmbSystem | None = None
        self.is_ct400_connected_state: bool = False
        self.camera_control_actions: dict[str, QAction] = {}
        self.cameras_menu: QMenu | None = None

        self.piezo_connection_succeeded.connect(self._on_piezo_connection_success)
        self.piezo_connection_failed.connect(self._on_piezo_connection_failed)

        # Threading members for asynchronous camera initialization
        self.camera_init_threads: list[QThread] = []
        self.camera_init_workers: list[CameraInitWorker] = []

        # --- UI and deferred initialization ---
        self._init_ui()
        self._load_defaults_from_config()
        self._connect_signals()

        # Start slow hardware initializations after the main event loop has started.
        # This ensures the GUI is responsive immediately upon launch.
        QTimer.singleShot(100, self._begin_lazy_init)
        logger.info("MainWindow __init__ complete. Hardware initialization deferred.")

    piezo_connection_succeeded = Signal(str)
    piezo_connection_failed = Signal(str, str)

    @Slot(str)
    def connect_piezo(self, side: str):
        """Connects or disconnects a piezo controller on a worker thread."""
        if side == "left":
            piezo = self.piezo_left
            action = self.piezo_connect_left_action
            port = self.config.instruments.piezo_left_serial
        else:
            piezo = self.piezo_right
            action = self.piezo_connect_right_action
            port = self.config.instruments.piezo_right_serial

        if not piezo:
            logger.error(f"Cannot connect {side} piezo: object is None.")
            return

        do_connect = not piezo.is_connected()

        worker = PiezoConnectionWorker(piezo, side, port, do_connect)

        # Connect signals to the main thread's *slots*
        worker.signals.connection_succeeded.connect(self.piezo_connection_succeeded)
        worker.signals.disconnection_succeeded.connect(
            self._on_piezo_disconnection_success
        )
        worker.signals.connection_failed.connect(self.piezo_connection_failed)

        # Update UI to show "in-progress" state
        action.setEnabled(False)
        action.setText(
            f"{'Connecting' if do_connect else 'Disconnecting'} {side.capitalize()}..."
        )

        QThreadPool.globalInstance().start(worker)

    @Slot(str)
    def _on_piezo_connection_success(self, side: str):
        logger.info(f"{side.capitalize()} Piezo connected successfully.")
        action = (
            self.piezo_connect_left_action
            if side == "left"
            else self.piezo_connect_right_action
        )
        action.setText(f"Disconnect {side.capitalize()} Piezo")
        action.setEnabled(True)
        self.statusBar().showMessage(f"{side.capitalize()} Piezo connected.", 3000)

        # --- Activate Alignment Panel if all hardware is now ready ---
        if (
            self.piezo_left
            and self.piezo_left.is_connected()
            and self.piezo_right
            and self.piezo_right.is_connected()
            and self.ct400_device
        ):
            logger.info("All alignment hardware is now connected. Activating panel.")
            self.alignment_tab.set_hardware(
                self.ct400_device, self.piezo_left, self.piezo_right
            )

    @Slot(str)
    def _on_piezo_disconnection_success(self, side: str):
        logger.info(f"{side.capitalize()} Piezo disconnected.")
        action = (
            self.piezo_connect_left_action
            if side == "left"
            else self.piezo_connect_right_action
        )
        action.setText(f"Connect {side.capitalize()} Piezo")
        action.setEnabled(True)
        self.statusBar().showMessage(f"{side.capitalize()} Piezo disconnected.", 3000)
        # De-activate alignment panel
        self.alignment_tab.set_hardware_ready(False)

    @Slot(str, str)
    def _on_piezo_connection_failed(self, side: str, error_message: str):
        logger.error(f"Failed to connect {side} piezo: {error_message}")
        action = (
            self.piezo_connect_left_action
            if side == "left"
            else self.piezo_connect_right_action
        )
        action.setText(f"Connect {side.capitalize()} Piezo")  # Revert text
        action.setEnabled(True)
        QMessageBox.critical(
            self,
            f"{side.capitalize()} Piezo Error",
            f"Operation failed: {error_message}",
        )
        # De-activate alignment panel
        self.alignment_tab.set_hardware_ready(False)

    @Slot(str, str)
    def _on_ct400_status_updated(self, state_name: str, message: str):
        """Updates the status bar from the CT400 init worker."""
        try:
            state = CT400Status[state_name.upper()]
        except KeyError:
            state = CT400Status.UNKNOWN

        self._update_ct400_visuals(state=state, message=message)

    @Slot(AbstractCT400)
    def _on_ct400_initialized(self, device: AbstractCT400):
        """
        Receives the initialized CT400 device (real or dummy) from the worker.
        This slot is now responsible for populating the rest of the UI
        that depends on the CT400.
        """
        logger.info(f"CT400 initialization finished. Received device: {type(device)}")
        self.ct400_device = device

        # Now that the device exists, pass it to the control panels
        self.control_panel.set_instrument(self.ct400_device)
        self.histogram_control.set_instrument(self.ct400_device)

        # Update UI visuals based on whether the device is real or dummy
        is_real_ct400 = isinstance(self.ct400_device, CT400)
        self.control_panel.on_instrument_connected(is_real_ct400)
        self.histogram_control.on_instrument_connected(is_real_ct400)

        if is_real_ct400:
            self._update_ct400_visuals(
                state=CT400Status.DISCONNECTED, message="CT400 Ready (Disconnected)"
            )
        else:
            # The status was already set to UNAVAILABLE by the worker's error
            pass

        # Now, check if the piezos finished first. If so, update the alignment tab.
        if self.piezo_left and self.piezo_right:
            logger.info(
                "CT400 is ready, and piezos are already initialized. Setting alignment hardware."
            )
            self.alignment_tab.set_hardware(
                self.ct400_device, self.piezo_left, self.piezo_right
            )

    def _begin_lazy_init(self):
        """Starts all slow hardware initializations on background threads."""
        logger.info("Starting lazy initialization of hardware...")

        # 1. Start Piezo discovery (already asynchronous, good)
        self._init_piezos_lazy()

        # 2. Start CT400 initialization (NOW asynchronous)
        self._init_ct400_lazy()

        # 3. Start Vimba system (still blocking, we'll fix this next)
        self._start_vimbasystem()
        if self.vmb_instance:
            self._init_cameras_lazy()
        else:
            logger.error("VimbaSystem not active, skipping camera initialization.")
            if self.camera_container.layout():
                error_label = QLabel(
                    "Vimba API could not be initialized. Cameras unavailable."
                )
                error_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
                self.camera_container.layout().addWidget(error_label)

    def _init_ct400_lazy(self):
        """Initializes the CT400 on a background thread."""
        logger.info("Starting lazy initialization of CT400...")
        self.ct400_init_thread = QThread(self)
        self.ct400_init_worker = CT400InitWorker(config=self.config)
        self.ct400_init_worker.moveToThread(self.ct400_init_thread)

        # Connect signals
        self.ct400_init_worker.ct400_initialized.connect(self._on_ct400_initialized)
        self.ct400_init_worker.status_updated.connect(self._on_ct400_status_updated)

        # Connect thread management
        self.ct400_init_thread.started.connect(self.ct400_init_worker.run)
        self.ct400_init_worker.ct400_initialized.connect(self.ct400_init_thread.quit)
        self.ct400_init_thread.finished.connect(self.ct400_init_worker.deleteLater)

        self.ct400_init_thread.start()

    def _init_piezos_lazy(self):
        """Initializes the Piezo controllers on a background thread."""
        logger.info("Starting lazy initialization of Piezo controllers...")

        self.piezo_init_thread = QThread(self)
        self.piezo_init_worker = PiezoInitWorker(config=self.config.instruments)
        self.piezo_init_worker.moveToThread(self.piezo_init_thread)

        # Connect signals
        self.piezo_init_worker.piezos_initialized.connect(self._on_piezos_initialized)
        self.piezo_init_worker.initialization_failed.connect(self._on_piezo_init_failed)
        self.piezo_init_thread.started.connect(self.piezo_init_worker.run)

        # --- FIX: REVISED CLEANUP LOGIC ---
        # 1. The worker's completion signal should quit the thread's event loop.
        self.piezo_init_worker.piezos_initialized.connect(self.piezo_init_thread.quit)
        self.piezo_init_worker.initialization_failed.connect(
            self.piezo_init_thread.quit
        )

        # 2. The thread's finished signal should ONLY clean up the WORKER.
        #    DO NOT connect it to self.piezo_init_thread.deleteLater() here.
        #    The MainWindow will now be responsible for deleting the thread itself on close.
        self.piezo_init_thread.finished.connect(self.piezo_init_worker.deleteLater)
        # --- END OF FIX ---

        self.piezo_init_thread.start()

    def _start_vimbasystem(self):
        """Initializes and enters the main VimbaSystem context.

        This must be done once before any camera operations can occur.
        """
        if self.vmb_instance is not None:
            logger.info("VmbSystem already active.")
            return
        try:
            logger.info("Attempting to start VmbSystem...")
            self.vmb_instance = VmbSystem.get_instance()
            self.vmb_instance.__enter__()
            logger.info("VmbSystem entered successfully.")
        except VmbSystemError as e:
            logger.error(f"Failed to enter VmbSystem: {e}", exc_info=True)
            self.vmb_instance = None
            QMessageBox.critical(
                self,
                "Vimba System Error",
                f"Could not initialize Vimba API: {e}\nCameras will be unavailable.",
            )
        except Exception as e:
            logger.critical(f"Unexpected error starting VmbSystem: {e}", exc_info=True)
            self.vmb_instance = None
            QMessageBox.critical(
                self,
                "Vimba System Error",
                f"An unexpected error occurred while starting Vimba API: {e}\nCameras will be unavailable.",
            )

    def _cleanup_vimbasystem(self):
        """Exits the VimbaSystem context cleanly."""
        if self.vmb_instance:
            logger.info("Attempting to exit VmbSystem...")
            try:
                self.vmb_instance.__exit__(None, None, None)
                logger.info("VmbSystem exited successfully.")
            except VmbSystemError as e:
                logger.error(f"Failed to exit VmbSystem: {e}", exc_info=True)
            except Exception as e:
                logger.critical(
                    f"Unexpected error exiting VmbSystem: {e}", exc_info=True
                )
            finally:
                self.vmb_instance = None

    def _load_defaults_from_config(self):
        """Load default values from config into UI elements."""
        logger.debug("Loading UI defaults from configuration...")
        try:
            if hasattr(self, "control_panel") and self.control_panel:
                scan_defaults = self.config.scan_defaults
                self.control_panel.initial_wl.setText(
                    str(scan_defaults.start_wavelength_nm)
                )
                self.control_panel.final_wl.setText(
                    str(scan_defaults.end_wavelength_nm)
                )
                self.control_panel.resolution.setText(str(scan_defaults.resolution_pm))
                self.control_panel.motor_speed.setText(str(scan_defaults.speed_nm_s))
                self.control_panel.laser_power.setText(str(scan_defaults.laser_power))
                power_unit_idx = self.control_panel.power_unit.findText(
                    scan_defaults.power_unit
                )
                if power_unit_idx != -1:
                    self.control_panel.power_unit.setCurrentIndex(power_unit_idx)
                for i in range(self.control_panel.input_port.count()):
                    if (
                        self.control_panel.input_port.itemData(i).value
                        == scan_defaults.input_port
                    ):
                        self.control_panel.input_port.setCurrentIndex(i)
                        break

            if hasattr(self, "histogram_control") and self.histogram_control:
                hist_defaults = self.config.histogram_defaults
                self.histogram_control.wavelength_input.setText(
                    str(hist_defaults.wavelength_nm)
                )
                self.histogram_control.laser_power.setText(
                    str(hist_defaults.laser_power)
                )
                power_unit_idx_hist = self.histogram_control.power_unit.findText(
                    hist_defaults.power_unit
                )
                if power_unit_idx_hist != -1:
                    self.histogram_control.power_unit.setCurrentIndex(
                        power_unit_idx_hist
                    )
                for i in range(self.histogram_control.input_port.count()):
                    if (
                        self.histogram_control.input_port.itemData(i).value
                        == hist_defaults.input_port
                    ):
                        self.histogram_control.input_port.setCurrentIndex(i)
                        break
                if hasattr(self.histogram_control, "detector_cbs"):
                    for i, checkbox in enumerate(self.histogram_control.detector_cbs):
                        is_enabled = getattr(
                            hist_defaults, f"detector_{i + 1}_enabled", False
                        )
                        checkbox.setChecked(is_enabled)
        except Exception as e:
            logger.error(f"Error loading defaults from config: {e}", exc_info=True)
            self.statusBar.showMessage("Error loading defaults from config", 5000)

    def _init_ui(self):
        """Constructs the main user interface of the application."""
        logger.debug("Initializing UI...")
        self.setWindowTitle(self.config.app_name)
        self.setWindowIcon(QIcon(":/icons/laser.svg"))
        self.setMinimumSize(1200, 800)

        try:
            screen = QApplication.primaryScreen().availableGeometry()
            width_ratio = self.config.ui.initial_width_ratio
            height_ratio = self.config.ui.initial_height_ratio
            self.resize(
                int(screen.width() * width_ratio), int(screen.height() * height_ratio)
            )
        except Exception as e:
            logger.warning(f"Could not set initial size based on screen: {e}")
            self.resize(1280, 850)

        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        main_layout = QVBoxLayout(central_widget)
        main_layout.setContentsMargins(5, 5, 5, 5)
        main_layout.setSpacing(5)
        splitter = QSplitter(Qt.Orientation.Vertical)
        splitter.setHandleWidth(6)
        splitter.setChildrenCollapsible(False)
        self.camera_container = QWidget()
        cam_layout = QHBoxLayout(self.camera_container)
        cam_layout.setContentsMargins(0, 0, 0, 0)
        cam_layout.setSpacing(5)
        control_container = QWidget()
        control_layout = QVBoxLayout(control_container)
        control_layout.setContentsMargins(0, 0, 0, 0)
        control_layout.setSpacing(5)
        self.tab_widget = QTabWidget()
        self.tab_widget.setSizePolicy(
            QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding
        )
        control_layout.addWidget(self.tab_widget)
        splitter.addWidget(self.camera_container)
        splitter.addWidget(control_container)
        initial_cam_height = int(self.height() * 0.6)
        splitter.setSizes([initial_cam_height, self.height() - initial_cam_height])
        main_layout.addWidget(splitter)

        # --- IMPORTANT: Pass None for ct400_device initially ---
        self.first_tab = QWidget()
        first_tab_layout = QHBoxLayout(self.first_tab)
        self.control_panel = CT400ControlPanel(
            self.shared_scan_settings, None, self.config
        )
        self.plot_widget = PlotWidget(self.shared_scan_settings)
        first_tab_layout.addWidget(self.control_panel, stretch=0)
        first_tab_layout.addWidget(self.plot_widget, stretch=1)
        self.tab_widget.addTab(self.first_tab, "Wavelength Scan")

        self.second_tab = QWidget()
        second_tab_layout = QHBoxLayout(self.second_tab)
        self.histogram_control = HistogramControlPanel(None, self.config)
        hist_detector_keys = [cb.text() for cb in self.histogram_control.detector_cbs]
        self.histogram_widget = HistogramWidget(
            self.histogram_control, hist_detector_keys
        )
        second_tab_layout.addWidget(self.histogram_control, stretch=0)
        second_tab_layout.addWidget(self.histogram_widget, stretch=1)
        self.tab_widget.addTab(self.second_tab, "Power Monitor")

        self.alignment_tab = AlignmentPanel(None, None, None, self)
        self.alignment_tab.setStyleSheet(CT400_CONTROL_PANEL_STYLE)
        self.tab_widget.addTab(self.alignment_tab, "Auto Alignment")

        self.setStatusBar(QStatusBar())
        self.ct400_status_label = QLabel("CT400: Initializing...")
        self.ct400_status_label.setObjectName(ID_CT400_STATUS_LABEL)
        self.statusBar().addPermanentWidget(self.ct400_status_label)
        self.statusBar().showMessage("Ready.")

        self._create_menus()

        self._update_ct400_visuals(state=CT400Status.UNKNOWN, message="Initializing...")
        logger.debug("UI Initialization finished.")

    @Slot(object, object)
    def _on_piezos_initialized(
        self, piezo_left: PiezoController | None, piezo_right: PiezoController | None
    ):
        logger.info("MainWindow: Piezo discovery finished.")
        self.piezo_left = piezo_left
        self.piezo_right = piezo_right

        # --- New logic to configure menu based on discovery ---
        if self.piezo_left:
            self.piezo_connect_left_action.setEnabled(True)
            self.piezo_connect_left_action.setText("Connect Left Piezo")
            self.piezo_connect_left_action.setToolTip(
                f"Found on {self.config.instruments.piezo_left_serial}"
            )
        else:
            self.piezo_connect_left_action.setEnabled(False)
            self.piezo_connect_left_action.setText("Left Piezo (Not Found)")
            self.piezo_connect_left_action.setToolTip(
                "Device not found. Check connection and config.ini."
            )

        if self.piezo_right:
            self.piezo_connect_right_action.setEnabled(True)
            self.piezo_connect_right_action.setText("Connect Right Piezo")
            self.piezo_connect_right_action.setToolTip(
                f"Found on {self.config.instruments.piezo_right_serial}"
            )
        else:
            self.piezo_connect_right_action.setEnabled(False)
            self.piezo_connect_right_action.setText("Right Piezo (Not Found)")
            self.piezo_connect_right_action.setToolTip(
                "Device not found. Check connection and config.ini."
            )
        # --- End new logic ---

        # Only set hardware if the CT400 worker has ALREADY finished.
        if self.ct400_device:
            logger.info(
                "Piezos are ready, and CT400 is already initialized. Setting alignment hardware."
            )
            self.alignment_tab.set_hardware(
                self.ct400_device, self.piezo_left, self.piezo_right
            )
        else:
            # This is normal, the CT400 worker is just slower.
            logger.info("Piezos are ready. Waiting for CT400 to initialize...")

    @Slot(str)
    def _on_piezo_init_failed(self, error_message: str):
        logger.error(f"Piezo initialization failed: {error_message}")
        QMessageBox.critical(
            self,
            "Piezo Error",
            f"Could not initialize Piezo controllers:\n{error_message}\n\nAlignment tab will be unavailable.",
        )
        self.piezo_connect_left_action.setEnabled(False)
        self.piezo_connect_right_action.setEnabled(False)
        # The tab remains disabled, so no further action is needed on it.

    def _update_ct400_visuals(self, state: CT400Status, message: str | None = None):
        """Updates all UI elements related to the CT400 connection status.

        This centralizes the logic for updating the menu action, status bar label,
        and main status message based on the device's state.

        Args:
            state: The new CT400Status to reflect in the UI.
            message: An optional message to display in the status bar.
        """
        action = getattr(self, "ct400_connect_action", None)
        label = getattr(self, "ct400_status_label", None)
        if not action or not label:
            return

        action_enabled, action_checked = True, False
        status_property = state.name.lower()

        state_map = {
            CT400Status.CONNECTED: (
                "Disconnect CT400",
                ":/icons/disconnect.svg",
                True,
                True,
            ),
            CT400Status.DISCONNECTED: (
                "Connect CT400",
                ":/icons/connect.svg",
                True,
                False,
            ),
            CT400Status.CONNECTING: (
                "Connecting...",
                ":/icons/spinner.svg",
                False,
                True,
            ),
            CT400Status.DISCONNECTING: (
                "Disconnecting...",
                ":/icons/spinner.svg",
                False,
                False,
            ),
            CT400Status.ERROR: (
                "Connect CT400 (Error)",
                ":/icons/connect.svg",
                True,
                False,
            ),
            CT400Status.UNAVAILABLE: (
                "CT400 Unavailable",
                ":/icons/laser.svg",
                False,
                False,
            ),
            CT400Status.UNKNOWN: (
                "CT400 Initializing",
                ":/icons/spinner.svg",
                False,
                False,
            ),
        }

        text, icon, action_enabled, action_checked = state_map[state]
        action.setText(text)
        action.setIcon(QIcon(icon))
        action.setEnabled(action_enabled and isinstance(self.ct400_device, CT400))
        action.setChecked(action_checked)

        label.setText(f"CT400: {state.name.replace('_', ' ').title()}")
        label.setProperty(PROP_STATUS, status_property)
        label.style().unpolish(label)
        label.style().polish(label)

        if message:
            timeout = (
                5000
                if state
                in [CT400Status.CONNECTED, CT400Status.DISCONNECTED, CT400Status.ERROR]
                else 0
            )
            self.statusBar().showMessage(message, timeout)

        if state == CT400Status.ERROR:
            QTimer.singleShot(
                3000,
                lambda: self._update_ct400_visuals(
                    CT400Status.DISCONNECTED, "Error occurred. Ready to connect."
                ),
            )

        self.is_ct400_connected_state = state == CT400Status.CONNECTED

    def _create_menus(self):
        """Creates the main menu bar and all its actions."""
        logger.debug("Creating menus...")
        menu_bar = self.menuBar()

        file_menu = menu_bar.addMenu("&File")
        exit_action = QAction(QIcon(":/icons/exit.svg"), "E&xit", self)
        exit_action.setStatusTip("Exit the application")
        exit_action.triggered.connect(self.close)
        file_menu.addAction(exit_action)

        self.instrument_menu = menu_bar.addMenu("&Instruments")
        self.ct400_connect_action = QAction(self)
        self.ct400_connect_action.setCheckable(True)
        self.ct400_connect_action.setStatusTip("Connect/Disconnect CT400 device")
        self.ct400_connect_action.triggered.connect(
            self._handle_ct400_connect_action_triggered
        )
        self.instrument_menu.addAction(self.ct400_connect_action)

        self.cameras_menu = menu_bar.addMenu("&Cameras")
        discover_action = QAction("Discover Cameras...", self)
        discover_action.setStatusTip("List all available Vimba cameras and their IDs")
        discover_action.triggered.connect(self._show_camera_discovery_dialog)
        self.cameras_menu.addSeparator()
        self.cameras_menu.addAction(discover_action)
        self.cameras_menu.addSeparator()  # Add another separator for neatness

        self.piezo_connect_left_action = QAction("Connect Left Piezo", self)
        self.piezo_connect_left_action.triggered.connect(
            lambda: self.connect_piezo("left")
        )
        self.instrument_menu.addAction(self.piezo_connect_left_action)

        self.piezo_connect_right_action = QAction("Connect Right Piezo", self)
        self.piezo_connect_right_action.triggered.connect(
            lambda: self.connect_piezo("right")
        )
        self.instrument_menu.addAction(self.piezo_connect_right_action)

        help_menu = menu_bar.addMenu("&Help")
        about_action = QAction("&About", self)
        about_action.setStatusTip("Show application information")
        about_action.triggered.connect(self._show_about_dialog)
        help_menu.addAction(about_action)
        logger.debug("Menus created.")

    @Slot()
    def connect_piezo(self, side: str):
        """Connects or disconnects a piezo controller."""
        piezo = self.piezo_left if side == "left" else self.piezo_right
        action = (
            self.piezo_connect_left_action
            if side == "left"
            else self.piezo_connect_right_action
        )

        if not piezo:
            return

        # Simplified connection logic. For a real implementation, use a QRunnable/QThread worker
        # just like the CT400 connection to avoid blocking the GUI.
        try:
            if piezo.is_connected():
                piezo.disconnect()
                action.setText(f"Connect {side.capitalize()} Piezo")
                self.statusBar().showMessage(
                    f"{side.capitalize()} Piezo disconnected.", 3000
                )
            else:
                serial_number = (
                    self.config.instruments.piezo_left_serial
                    if side == "left"
                    else self.config.instruments.piezo_right_serial
                )

                logger.info(
                    f"Attempting to connect to {side} piezo with S/N: {serial_number}"
                )
                piezo.connect(serial_number)
                action.setText(f"Disconnect {side.capitalize()} Piezo")
                self.statusBar().showMessage(
                    f"{side.capitalize()} Piezo connected.", 3000
                )
        except PiezoError as e:
            logger.error(f"Failed to connect to {side} piezo: {e}", exc_info=True)
            QMessageBox.critical(self, "Piezo Connection Error", str(e))
            action.setText(f"Connect {side.capitalize()} Piezo")

    @Slot()
    def _show_camera_discovery_dialog(self):
        """Shows the camera discovery dialog.

        Ensures the Vimba system is running before creating and executing the
        modal dialog to discover connected cameras.
        """
        if self.vmb_instance is None:
            QMessageBox.warning(
                self,
                "Vimba System Not Ready",
                "The Vimba API has not been initialized. Cannot discover cameras.\n"
                "Please ensure the Vimba SDK is installed correctly.",
            )
            return

        try:
            dialog = CameraDiscoveryDialog(self)
            dialog.exec()
        except Exception as e:
            logger.error(
                f"Failed to create or show camera discovery dialog: {e}", exc_info=True
            )
            QMessageBox.critical(
                self, "Dialog Error", f"Could not open the discovery dialog: {e}"
            )

    @Slot(bool)
    def _handle_ct400_connect_action_triggered(self, checked: bool):
        """Handles the CT400 connect/disconnect menu action.

        Starts a CT400ConnectionWorker on the global thread pool to perform
        the hardware operation without blocking the GUI. Updates the UI to
        reflect the connecting/disconnecting state.

        Args:
            checked: True if the action is toggled to a "checked" state (connect),
                     False otherwise (disconnect).
        """
        action = self.sender()
        if action:
            action.setEnabled(False)  # Prevent rapid re-clicks

        if not self.ct400_device or isinstance(self.ct400_device, DummyCT400):
            self._update_ct400_visuals(
                state=CT400Status.UNAVAILABLE, message="CT400 Not Initialized or Dummy."
            )
            if action:
                action.setChecked(False)
                action.setEnabled(True)
            return

        worker = CT400ConnectionWorker(self.ct400_device, self.config, connect=checked)
        worker.signals.connection_succeeded.connect(
            self._handle_ct400_connection_success
        )
        worker.signals.connection_failed.connect(self._handle_ct400_connection_failure)
        worker.signals.disconnection_succeeded.connect(
            self._handle_ct400_disconnection_success
        )
        worker.signals.disconnection_failed.connect(
            self._handle_ct400_connection_failure
        )
        worker.signals.finished.connect(
            lambda: self.ct400_connect_action.setEnabled(True)
        )

        if checked:
            self._update_ct400_visuals(
                state=CT400Status.CONNECTING, message="CT400: Attempting to connect..."
            )
        else:
            self._update_ct400_visuals(
                state=CT400Status.DISCONNECTING, message="CT400: Disconnecting..."
            )

        QThreadPool.globalInstance().start(worker)

    @Slot(str)
    def _handle_ct400_connection_success(self, message: str):
        """Slot to handle a successful CT400 connection."""
        self._update_ct400_visuals(state=CT400Status.CONNECTED, message=message)
        self.control_panel.on_instrument_connected(True)
        self.histogram_control.on_instrument_connected(True)

    @Slot(str)
    def _handle_ct400_connection_failure(self, error_message: str):
        """Slot to handle a failed CT400 connection or disconnection."""
        self._update_ct400_visuals(state=CT400Status.ERROR, message=error_message)
        self.control_panel.on_instrument_connected(False)
        self.histogram_control.on_instrument_connected(False)

    @Slot(str)
    def _handle_ct400_disconnection_success(self, message: str):
        """Slot to handle a successful CT400 disconnection."""
        self._update_ct400_visuals(state=CT400Status.DISCONNECTED, message=message)
        self.control_panel.on_instrument_connected(False)
        self.histogram_control.on_instrument_connected(False)

    def _show_about_dialog(self):
        """Displays the 'About' message box with application info."""
        app_name = self.config.app_name
        app_version = QApplication.applicationVersion()
        QMessageBox.about(
            self,
            f"About {app_name}",
            f"<b>{app_name}</b><br>"
            f"Version: {app_version}<br><br>"
            "IOPanel App.<br>"
            "(c) 2025 Simone Ferraresi/IOP Lab @ UniFe",
        )

    def _init_cameras_lazy(self):
        """Initializes all enabled cameras asynchronously.

        For each valid camera in the config, this method creates a placeholder
        UI panel, then spawns a dedicated worker thread (CameraInitWorker) to
        open the camera. This prevents the UI from freezing while waiting for
        multiple cameras to connect.
        """
        logger.info("Initializing cameras lazily...")
        if not all(
            [self.camera_container, self.camera_container.layout(), self.cameras_menu]
        ):
            logger.error(
                "UI components for camera initialization are not ready. Aborting."
            )
            return

        # Get a dictionary of valid camera configs, keyed by their identifier.
        camera_configs_to_init = {
            identifier: config
            for identifier, config in self.config.cameras.items()
            if self._should_initialize_camera(identifier, config)
        }

        if not camera_configs_to_init:
            self.cameras_menu.addAction(
                QAction("No enabled cameras found in config", self)
            ).setEnabled(False)
            logger.info("No valid, enabled cameras to initialize.")
            return

        # --- COMBINED LOOP: Create panel and start worker thread in one pass ---
        for identifier, config in camera_configs_to_init.items():
            logger.debug(
                f"Setting up initialization for camera '{config.name}' (ID: {identifier})"
            )

            # 1. Create and add the placeholder panel to the UI
            placeholder_panel = self._create_camera_panel(None, config)
            self.camera_panels[identifier] = placeholder_panel
            self.camera_container.layout().addWidget(placeholder_panel)

            # 2. Create the thread and worker for this specific camera
            thread = QThread(self)
            worker = CameraInitWorker(identifier=identifier, cam_config=config)
            worker.moveToThread(thread)

            # 3. Connect signals for this worker/thread instance
            worker.camera_initialized.connect(self._on_camera_initialized)
            worker.camera_initialized.connect(
                thread.quit
            )  # Tell thread to quit when done

            # 4. Connect cleanup signals
            thread.finished.connect(worker.deleteLater)
            thread.finished.connect(thread.deleteLater)
            # Remove the thread from our tracking list upon completion
            thread.finished.connect(
                lambda t=thread: self.camera_init_threads.remove(t)
                if t in self.camera_init_threads
                else None
            )

            # 5. Start the thread
            thread.started.connect(worker.run)
            thread.start()

            # 6. Keep a persistent reference to prevent garbage collection
            self.camera_init_threads.append(thread)
            self.camera_init_workers.append(worker)

    @Slot(str, object, CameraConfig)
    def _on_camera_initialized(
        self,
        identifier: str,
        camera_instance: VimbaCam | None,
        cam_config: CameraConfig,
    ):
        """Slot to handle a camera that has finished initializing.

        This method is called when a `CameraInitWorker` finishes. If the camera
        was initialized successfully, it connects the camera's signals to the
        UI panel, adds it to the list of active cameras, and creates a menu
        action for it. If it failed, it updates the panel to show an error state.

        Args:
            identifier: The unique ID of the camera that was initialized.
            camera_instance: The live `VimbaCam` object if successful, else `None`.
            cam_config: The configuration object for the camera.
        """
        panel = self.camera_panels.get(identifier)  # Find panel by identifier
        if not panel:
            logger.error(f"Could not find panel for camera config: {cam_config.name}")
            if camera_instance:
                camera_instance.close()
            return

        if camera_instance:
            logger.info(f"Camera '{cam_config.name}' is online. Connecting to UI.")
            self.cameras.append(camera_instance)

            panel.set_camera(camera_instance)
            self._connect_camera_signals(camera_instance, panel)
            self._create_camera_menu_action(camera_instance, panel)
            panel.watchdog_timer.start()

            panel.video_label.setText(MSG_CAMERA_WAITING)
        else:
            logger.error(f"Failed to initialize camera '{cam_config.name}'.")
            error_msg = f"{cam_config.name}\n(Failed to Open)"
            panel.video_label.setText(error_msg)
            panel.video_label.setStyleSheet(
                "background-color: #ffebee; color: #c62828;"
            )

    def _should_initialize_camera(
        self, identifier: str, cam_config: "CameraConfig"
    ) -> bool:
        """Checks if a camera from the config should be initialized."""
        if not cam_config.enabled:
            logger.info(f"Skipping disabled camera: {cam_config.name}")
            return False
        if not identifier or identifier.startswith("PUT_"):
            logger.warning(
                f"Skipping camera '{cam_config.name}': Invalid or placeholder identifier."
            )
            error_msg = f"{cam_config.name}\n(Config Error: Invalid ID)"
            placeholder = self._create_camera_error_placeholder(error_msg)
            self.camera_container.layout().addWidget(placeholder)
            return False
        return True

    def _create_and_open_camera(self, cam_config: "CameraConfig") -> VimbaCam | None:
        """Creates a VimbaCam instance and attempts to open it. Returns instance or None."""
        try:
            cam_instance = VimbaCam(
                identifier=cam_config.identifier,
                camera_name=cam_config.name,
                flip_horizontal=cam_config.flip_horizontal,
                parent=self,
            )
            if not cam_instance.open():
                logger.error(
                    f"Failed to open camera {cam_config.name} (ID: {cam_config.identifier})."
                )
                error_msg = MSG_CAMERA_FAILED.format(cam_config.name)
                placeholder = self._create_camera_error_placeholder(error_msg)
                self.camera_container.layout().addWidget(placeholder)
                cam_instance.close()  # Clean up the failed instance
                return None
            return cam_instance
        except VmbCameraError as e:
            logger.error(
                f"Vimba Error initializing camera {cam_config.name} (ID: {cam_config.identifier}): {e}"
            )
            error_msg = f"{cam_config.name}\n(Vimba Error)"
            placeholder = self._create_camera_error_placeholder(error_msg)
            self.camera_container.layout().addWidget(placeholder)
            return None
        except Exception as e:
            logger.error(
                f"Unexpected error creating camera instance {cam_config.name}: {e}",
                exc_info=True,
            )
            error_msg = f"{cam_config.name}\n(Init Error)"
            placeholder = self._create_camera_error_placeholder(error_msg)
            self.camera_container.layout().addWidget(placeholder)
            return None

    def _create_camera_panel(
        self, cam_instance: VimbaCam | None, cam_config: "CameraConfig"
    ) -> CameraPanel:
        """Creates and returns a CameraPanel. Can be a placeholder if cam_instance is None."""
        panel = CameraPanel(
            cam_instance,
            cam_config.name,
            config=cam_config,
            parent=self.camera_container,
        )
        if not cam_instance:
            panel.video_label.setText(MSG_CAMERA_CONNECTING.format(cam_config.name))
        return panel

    def _connect_camera_signals(self, cam_instance: VimbaCam, panel: CameraPanel):
        """Connects signals between a camera instance and its UI panel."""
        # The connection to the worker is now handled inside CameraPanel.
        # We only need to connect the signals that the panel itself consumes.

        # This connection is now just for the watchdog timer
        cam_instance.new_frame.connect(panel.process_new_frame_data)

        cam_instance.fps_updated.connect(panel.update_fps)
        cam_instance.error.connect(panel._handle_camera_error_message)

    def _create_camera_menu_action(self, cam_instance: VimbaCam, panel: CameraPanel):
        """Creates and registers a menu action to control the camera panel's visibility."""
        action = QAction(self)
        action.setCheckable(True)
        action.setChecked(panel.get_controls_visible())
        action.setText(
            f"{'Hide' if panel.get_controls_visible() else 'Show'} {cam_instance.camera_name} Controls"
        )
        action.setData(cam_instance.identifier)
        action.triggered.connect(self._handle_camera_control_toggle)
        self.cameras_menu.addAction(action)
        self.camera_control_actions[cam_instance.identifier] = action

    def _create_camera_error_placeholder(self, message: str) -> QWidget:
        """Helper to create a consistent placeholder for camera errors."""
        placeholder_widget = QFrame()
        placeholder_widget.setObjectName("cameraErrorPlaceholder")
        placeholder_widget.setStyleSheet(
            "QFrame#cameraErrorPlaceholder {"
            "  border: 1px solid #ffcdd2;"
            "  border-radius: 5px;"
            "  background-color: #ffebee;"
            "}"
            "QLabel { color: #c62828; font-weight: normal; background: transparent; }"
        )
        placeholder_widget.setMinimumSize(220, 120)
        placeholder_widget.setMaximumWidth(350)
        placeholder_widget.setSizePolicy(
            QSizePolicy.Policy.Preferred, QSizePolicy.Policy.Preferred
        )

        layout = QVBoxLayout(placeholder_widget)
        layout.setContentsMargins(10, 10, 10, 10)
        layout.setSpacing(5)

        icon_label = QLabel()
        try:
            std_icon = self.style().standardIcon(
                QtWidgets.QStyle.StandardPixmap.SP_MessageBoxWarning
            )
            if not std_icon.isNull():
                icon_label.setPixmap(std_icon.pixmap(QSize(32, 32)))
        except Exception as e_icon:
            logger.warning(f"Could not load standard warning icon: {e_icon}")
            icon_label.setText("⚠️")
            icon_label.setFont(QFont("Segoe UI Symbol", 20))

        icon_label.setAlignment(Qt.AlignmentFlag.AlignCenter)

        text_label = QLabel(message)
        text_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        text_label.setWordWrap(True)

        layout.addWidget(icon_label)
        layout.addWidget(text_label)

        placeholder_widget.setToolTip(
            f"Camera Initialization Error: {message.replace('\n', ' ')}"
        )
        return placeholder_widget

    @Slot(bool)
    def _handle_camera_control_toggle(self, checked: bool):
        action = self.sender()
        if not isinstance(action, QAction):
            return

        camera_identifier = action.data()
        if camera_identifier in self.camera_panels:
            panel = self.camera_panels[camera_identifier]
            panel.set_controls_visibility(checked)
            action.setText(
                f"{'Hide' if checked else 'Show'} {panel._panel_title} Controls"
            )
        else:
            logger.warning(
                f"Camera panel not found for identifier: {camera_identifier} during toggle."
            )
            action.setChecked(not checked)
            action.setEnabled(False)

    @Slot(np.ndarray, np.ndarray, float)
    def _handle_scan_data(
        self,
        wavelengths: np.ndarray,
        plotting_power_data: np.ndarray,
        final_pout: float,
    ):
        logger.debug(
            f"Received scan data signal. Wavelength points: {len(wavelengths)}"
        )

        if self.plot_widget and hasattr(self.plot_widget, "update_plot"):
            try:
                self.plot_widget.update_plot(
                    wavelengths, plotting_power_data, final_pout
                )
            except Exception as e:
                logger.error(f"Error updating plot widget: {e}", exc_info=True)

    @Slot(dict)
    def handle_power_data(self, power_data: dict):
        logger.debug(f"Received power data: {power_data}")
        if self.histogram_widget and hasattr(self.histogram_widget, "schedule_update"):
            try:
                self.histogram_widget.schedule_update(power_data)
            except Exception as e:
                logger.error(f"Error updating histogram widget: {e}", exc_info=True)
        else:
            logger.warning(
                "Histogram widget not available or does not have schedule_update method."
            )

    def _cleanup_cameras(self):
        logger.info(f"Closing {len(self.cameras)} camera(s)...")

        # Stop any camera initialization threads that might still be running.
        # Iterate over a copy as the list might be modified by the thread's finished signal.
        threads_to_stop = list(self.camera_init_threads)
        for thread in threads_to_stop:
            if thread.isRunning():
                logger.warning(
                    "Force-quitting an incomplete camera init thread during shutdown."
                )
                thread.quit()
                thread.wait(500)  # Give it a moment to quit
        self.camera_init_threads.clear()
        self.camera_init_workers.clear()

        # Disconnect menu actions
        if hasattr(self, "cameras_menu") and self.cameras_menu is not None:
            for cam_id in list(self.camera_control_actions.keys()):
                action = self.camera_control_actions.pop(cam_id, None)
                if action:
                    self.cameras_menu.removeAction(action)
                    action.deleteLater()
        self.camera_control_actions.clear()

        # Remove panels from the UI
        if (
            hasattr(self, "camera_container")
            and self.camera_container.layout() is not None
        ):
            layout = self.camera_container.layout()
            while layout.count():
                item = layout.takeAt(0)
                widget = item.widget()
                if widget is not None:
                    # This ensures the panel's own closeEvent is called if it has one
                    widget.close()
                    widget.deleteLater()

        # Close the actual camera hardware instances
        cameras_to_close = list(self.cameras)
        self.cameras.clear()
        self.camera_panels.clear()

        for cam in cameras_to_close:
            if cam is not None:
                logger.debug(f"Closing camera: {cam.camera_name}")
                try:
                    # The camera's close() method handles stopping streaming etc.
                    cam.close()
                except Exception as e:
                    logger.error(
                        f"Error closing camera {cam.camera_name}: {e}", exc_info=True
                    )

        logger.info("Camera cleanup finished.")

    def closeEvent(self, event: QtGui.QCloseEvent):
        """
        Handles the user closing the window. Ensures all hardware and threads
        are shut down gracefully. This is the single source of truth for cleanup.
        """
        logger.info("Application close requested. Initiating shutdown sequence...")
        self.statusBar().showMessage("Shutting down...", 0)

        # 1. Stop all worker threads and background tasks first.
        #    This prevents them from trying to access hardware that is about to be disconnected.

        if self.ct400_init_thread and self.ct400_init_thread.isRunning():
            logger.info("MainWindow.closeEvent: Quitting active CT400 init thread.")
            if self.ct400_init_worker:
                self.ct400_init_worker.stop()
            self.ct400_init_thread.quit()
            if not self.ct400_init_thread.wait(500):
                logger.warning("CT400 init thread did not quit gracefully on close.")
                self.ct400_init_thread.terminate()

        # Quit the piezo init thread if it's still running (it shouldn't be, but this is safe).
        if self.piezo_init_thread and self.piezo_init_thread.isRunning():
            logger.info("MainWindow.closeEvent: Quitting active piezo init thread.")
            self.piezo_init_thread.quit()
            if not self.piezo_init_thread.wait(500):
                logger.warning("Piezo init thread did not quit gracefully on close.")
                self.piezo_init_thread.terminate()  # Force terminate if stuck

        # Cleanup long-running workers
        if hasattr(self, "alignment_tab") and self.alignment_tab:
            self.alignment_tab.cleanup()
        if hasattr(self, "histogram_control") and self.histogram_control:
            self.histogram_control.cleanup_worker_thread()
        if hasattr(self, "control_panel") and self.control_panel.is_busy():
            self.control_panel._stop_scan(cancelled=True)
            if self.control_panel.scan_thread:
                self.control_panel.scan_thread.wait(1000)

        # 2. Close all camera streams and wait for any remaining init threads.
        #    (This also implicitly calls the close() method on each VimbaCam instance).
        self._cleanup_cameras()

        # 3. Disconnect from physical hardware.
        if self.piezo_left and self.piezo_left.is_connected():
            self.piezo_left.disconnect()
        if self.piezo_right and self.piezo_right.is_connected():
            self.piezo_right.disconnect()

        # Disconnect from CT400 if it was connected.
        if self.ct400_device and self.is_ct400_connected_state:
            logger.info("MainWindow.closeEvent: Closing CT400 device connection.")
            self.ct400_device.close()

        # 4. Shut down the main Vimba system API.
        self._cleanup_vimbasystem()

        logger.info("Shutdown sequence complete. Accepting close event.")
        event.accept()

    def _connect_signals(self):
        """Connects signals between different components of the application."""
        if hasattr(self, "control_panel") and self.control_panel:
            logger.debug("Connecting control_panel signals")
            self.control_panel.scan_data_ready.connect(self._handle_scan_data)
            self.control_panel.progress_updated.connect(
                lambda value: self.statusBar().showMessage(
                    f"Scan Progress: {value}%", 1000 if value < 100 else 0
                )
            )
        else:
            logger.warning(
                "CT400 Control Panel not initialized, skipping signal connection."
            )

        if hasattr(self, "histogram_control") and self.histogram_control:
            logger.debug("Connecting histogram_control signals")
            self.histogram_control.power_data_ready.connect(self.handle_power_data)
        else:
            logger.warning(
                "Histogram Control Panel not initialized, skipping signal connection."
            )
